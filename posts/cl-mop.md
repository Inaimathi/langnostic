"mop" stands for "[Meta-Object](http://en.wikipedia.org/wiki/Metaobject) Protocol", and it's a term closely related to [CLOS](http://en.wikipedia.org/wiki/Common_Lisp_Object_System). I've mentioned getting annoyed at a certain piece of it [last time](http://langnostic.blogspot.ca/2011/09/mapping-clos-or-yak-shaving-for-fun-and.html), when I needed to iterate over CLOS instance slots for some weird reason. It turns out that due to the way MOP support is implemented, this is a non-trivial thing to do portably.

Last week, I got into a situation where I needed a temporary copy of an object. What I really wanted was an object with most slots mirroring an existing instance, but with changed values in two slots. For reasons related to the layout of the surrounding code, I did *not* want to destructively modify the object itself because it was unclear whether the old values would be expected on a subsequent call. So I googled around a bit, and found that the situation for copying is pretty much the same as it is for iterating. [There isn't a built-in, general way of making a copy of a CLOS instance](http://stackoverflow.com/questions/11067899/is-there-a-generic-method-for-cloning-clos-objects/11068536#comment15858244_11068536), shallow or otherwise, and implementing it myself in a semi-portable way would require doing all the annoying things that I had to pull with slot iteration earlier.

So, being that I occasionally profess to be a non-idiot programmer, I figured I'd take a stab at solving the problem in a semi-satisfactory way.

And [here we are](https://github.com/Inaimathi/cl-mop).

That implements `slot-names` (which takes a CLOS instance or class and returns a list of its slot names), `map-slots` (which takes a `(lambda (slot-name slot-value) ...)` and an instance, and maps over the bound slots of that instance), `shallow-copy` (which does exactly what it sounds like it would do) and `deep-copy` (which is tricky enough that I hereby direct you to the [documentation](https://github.com/Inaimathi/cl-mop/blob/master/README.md) and/or [code](https://github.com/Inaimathi/cl-mop/blob/master/cl-mop.lisp) if you're sufficiently curious about it).

I did cursory testing in [GNU Clisp](http://www.clisp.org/), and fairly extensive testing (followed by some production use) in [SBCL](http://www.sbcl.org/), though the `:shadowing-import` directive should work properly in a number of others as well.

Now, I realize that due to the kind of crap you can pull using CLOS by design, this isn't a complete solution. That said, it did solve the problems I was staring down, and I think I've made it portable/extensible enough that you'll be able to do more or less what you want in a straight-forward way. For basic use cases, it solves the problem outright, which should save me a bit of time in the coming weeks. For more complex cases, each of the exported symbols is a `method`, which means you can easily `def` your own if you need to treat a certain class differently from others.
