<p>That <a href="https://github.com/Inaimathi/Common-Lisp-Actors"><code>cl-actors</code> fork</a> has gotten a few hours thrown at it. This time around, I integrated the <a href="https://github.com/m2ym/optima">Optima pattern-matching library</a>, and made certain things a little easier. I'm nowhere near done yet though; in addition to the rest of the ToDos from <a href="http://langnostic.blogspot.ca/2013/03/actors.html">last time</a>, and seeing what I can do with <a href="https://github.com/deliciousrobots/green-threads">green threads</a>, I need to settle things that the Erlang guys have clearly been thinking about for a few years.</p>
<h2 id="first">First</h2>
<p>How do you deal with error reporting/handling here? And I specifically mean</p>
<pre class="common-lisp"><code>(defmethod initialize-instance :after ((self actor) &amp;amp;key)
  &quot;Uses the main function name to create a thread&quot;
  (with-slots (behavior in name thread) self
    (setf thread 
          (bt:make-thread 
           (lambda () 
             (loop
                (handler-case
                    (let ((res (funcall behavior (dequeue in))))
                      (loop for target in (targets self)
                         do (enqueue res target)))
                  (match-error (e)
                    (format t &quot;There isn&#39;t a match clause that fits. Do something more intelligent with unmatched messages.~%~a~%~%&quot; e))
                  (error (e)
                    (format t &quot;BLEARGH! I AM SLAIN! (this should kill the actor, and possibly call some fall-back mechanism)~%~a~%~%&quot; e)))))
           :name name))))</code></pre>
<p>here. Spitting unmatched messages out at <code>*standard-output*</code> sounds <em>kind of</em> ok, until you start thinking about how you'd deal with any kind of non-trivial system, or a situation where you want to defer those messages to someone else who might know how to deal with them. The standard <a href="http://www.erlang.org/doc/man/supervisor.html">Supervisor infrastructure</a> that Erlang implements looks like it would be a good solution, and will probably going to be easier to put together in Lisp. That's more or less the only sane option for things like unmatched messages, because you don't ever want those to derail the whole system.</p>
<p>The second <code>case</code> there is more ambiguous though.</p>
<p><code>common-lisp   (error (e)     (format t &quot;BLEARGH! I AM SLAIN! (this should kill the actor, and possibly call some fall-back mechanism)~%~a~%~%&quot; e))</code></p>
<p>That handles all other <code>error</code>s. Run-time snafus like passing the wrong number of arguments to <code>format</code>. For these, you do really, truly want to take the actor out of commission until it gets fixed; there's no point whatsoever in trying to process further messages until that time. So another reasonable approach here would be to use Common Lisp's built-in condition system. That is, re-raise the <code>error</code> and give the user a restart option to define a new behavior in-line.</p>
<p>I don't know, there might be pitfalls there that I'm not seeing, which is why I need to think pretty hard about it, and then try it out.</p>
<h2 id="second">Second</h2>
<p>I want to make sure that networks resulting from this system are flexible enough to withstand change. That's a tougher one, and the built in <a href="https://github.com/naveensundarg/Common-Lisp-Actors/blob/master/actors.lisp#L100-L104">behav</a> function from <a href="https://github.com/naveensundarg/Common-Lisp-Actors">the original <code>cl-actors</code></a> doesn't quite satisfy. The two things we want to preserve from an actor when we're modifying it, if we want robust networks, are its state and its inbound message queue. The second is hopefully obvious, but the first might not be given how that <code>behav</code> function I just linked is implemented. It leaves the task of assigning new state up to the user, who may not know what the latest state of the actor is. Worse than that, there may be no way for them to find out, because that state is locked away in a closure with no hooks other than the ones manually defined by the behavior they're trying to replace. I'm not entirely sure what the solution there is, but it probably won't be straightforward.</p>
<p>What I <em>apparently</em> want is a macro that takes a series of <code>ematch</code> clauses, and returns a macro that accepts a list of state variables/values, which returns a function that takes a message and returns whatever we want to pass on. I'd call that first macro to define the skeleton of my new behavior, then pass the result through to an actor which would provide its own internal state to fill in the gaps, then take the result of that operation and assign it to a new behavior. The end result would be a function which I can define on the outside somewhere, but which will take into consideration an actors most current internal state when finally applied. The queue, of course, goes nowhere, and assuming the new behavior function doesn't error out anywhere, the actor should continue <code>dequeue</code>ing on its merry way</p>
<h2 id="finally">Finally</h2>
<p>That &quot;assuming&quot; isn't to be glossed over. Replacing an actor or behavior with another is straightforward in toy examples, but in an actual, running system, you want good fail-over capabilities. Specifically, if the new guy chokes on his first couple of messages, you want the option of slotting in the old process before too much time has elapsed. You definitely <em>don't</em> want to grind the entire downstream system to a halt while the programmers figure out what the issue is with the new code. Another thing that might be useful is a default <code>:test</code> message that you can throw at an actor which should tell the sender whether it can respond to the given message. In a situation where you're replacing an existing actor with a new one, or just replacing the behavior of an existing actor, you want to know that the messages sent out by the new thing are going to be intelligible to their targets before committing to the change-over. How the reporting for this is going to work, I haven't the first clue, but I've got more than enough implementation to do already, so I'll probably leave that one for the next article.</p>
